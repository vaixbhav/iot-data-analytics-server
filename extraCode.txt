// int init_size = forecasts.size(); 

        // for (int i = init_size - 1; i < init_size + n + 10; i++) {
        //     forecasts.add(getAverage(forecasts.get(i), forecasts.get(i - 1)));
        // }

        // public List<Double> predictNextNValues(int n) {
    //     ArrayList<Double> predictionList = new ArrayList<>(startingValues);
    //     for(int i = 0; i < n; i++) {
    //         predictionList = (ArrayList<Double>) predictNext(predictionList);
    //     }
    //     return predictionList;
    // }

    // public List<Double> predictNext(List<Double> observedValues) {
    //     if (observedValues.isEmpty()) {
    //         throw new IllegalStateException("Observed values list is empty. Please provide observed values before predicting.");
    //     }
    //     double alpha = 0.2;

    //     ArrayList<Double> predictedValues = new ArrayList<>(observedValues);
    //     double nextValue = alpha * predictedValues.get(predictedValues.size() - 1)
    //                 + (1 - alpha) * predictedValues.get(predictedValues.size() - 1);
    //         predictedValues.add(nextValue);

            
    //     return predictedValues;
    //     }

    // double alpha = 0.6;
        // System.out.println("Alpha: " + alpha); 
        // double forecast; 
        // List<Double> forecasts = new ArrayList<Double>(); 

        //     for (int i = 0; i < 100; i++) {
        //         if(i == 0){
        //             forecast = actualValues.get(i); 
        //         }
        //         else{
        //             forecast = alpha * actualValues.get(i - 1) + (1 - alpha) * forecasts.get(i - 1);  // Replace with tsCurrent
        //         }
        //         forecasts.add(forecast); 

        //         if(i + 1>= actualValues.size()){
        //             actualValues.add(forecast); 
        //         }
        //     }
        //     // printer(actualValues);
     
        // printer(forecasts);


         /*public static List<Double> checkPrediction(List<Double> startingValues, int n) {
        if(startingValues.size() >= 3) {
            if(Objects.equals(startingValues.get(0), startingValues.get(2)) && !Objects.equals(startingValues.get(0), startingValues.get(1))) {
                return alternatePrediction(startingValues, n);
            }
        }
        return extrapolate(startingValues, n);
    } */